package org.evosuite.runtime;

import org.evosuite.runtime.instrumentation.InstrumentingClassLoader;
import org.evosuite.runtime.mock.MockFramework;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.InitializationError;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Special JUnit Runner needed for the test cases generated by EvoSuite
 * 
 * @author arcuri
 *
 */
public class EvoRunner extends BlockJUnit4ClassRunner {

	/*
	 * We need this class due to some weird behavior of JVM
	 */
	
	private static final Logger logger = LoggerFactory.getLogger(EvoRunner.class);

	/**
	 * Dirty hack, to use with care.
	 * In some very special cases, we want to skip agent instrumentation.
	 * Still, we would need to use a classloader that will do such instrumentation.
	 * This is for example done in -measureCoverage, as we need a more details instrumentation,
	 * and, at the same time, we want to avoid a double instrumentation from agent
	 */
	public static boolean useAgent = true;


	public EvoRunner(Class<?> klass)
			throws InitializationError {
		/*
		 * extremely important that getClass is called _BEFORE_ super is executed.
		 * The constructor of BlockJUnit4ClassRunner does reflection on klass, eg
		 * to check that it has only one constructor.
		 * For some arcane reasons, such reflection code ends up in native JVM code
		 * that "might" start the loading of some classes whose type is used for
		 * variables and casting inside the methods of "klass", 
		 * although the code of those methods is _NOT_ executed (note: not
		 * talking of static initializers here).
		 */
		super(getClass(klass));		
	}

	private static Class<?> getClass(Class<?> klass) throws InitializationError{
		
		EvoRunnerParameters ep = klass.getAnnotation(EvoRunnerParameters.class);
		
		if(ep == null){
			throw new IllegalStateException("EvoSuite test class "+klass.getName()+
					" is not annotated with "+EvoRunnerParameters.class.getName());
		}
		
		RuntimeSettings.resetStaticState = ep.resetStaticState();
		RuntimeSettings.mockJVMNonDeterminism = ep.mockJVMNonDeterminism();
		RuntimeSettings.useVFS = ep.useVFS();
		RuntimeSettings.useVNET = ep.useVNET();
        RuntimeSettings.useSeparateClassLoader = ep.separateClassLoader();
		RuntimeSettings.useJEE = ep.useJEE();

		if(RuntimeSettings.useSeparateClassLoader) {
			return getFromEvoSuiteClassloader(klass);
		}

		if(useAgent) {
			org.evosuite.runtime.agent.InstrumentingAgent.initialize();
		}

		org.evosuite.runtime.agent.InstrumentingAgent.activate();
		
		try {
			/*
			 *  be sure that reflection on "klass" is executed here when
			 *  the agent is active
			 */
			klass.newInstance();
		} catch (InstantiationException | IllegalAccessException e) {
			//shouldn't really happen
			logger.error("Failed to initialize test class "+klass.getName());
		}
		org.evosuite.runtime.agent.InstrumentingAgent.deactivate();

		return klass;
	}
	
	private static Class<?> getFromEvoSuiteClassloader(Class<?> clazz) throws InitializationError {
	    try {
	    	/*
	    	 *  properties like REPLACE_CALLS will be set directly in the JUnit files
	    	 */

	    	// LoggingUtils.loadLogbackForEvoSuite();

	    	/*
	    	 * TODO: this approach does throw away all the possible instrumentation done on the input clazz,
	    	 * eg code coverage of Emma, Cobertura, Javalanche, etc.
	    	 * 
	    	 * maybe an option would be to use java agents:
	    	 * 
	    	 * http://dhruba.name/2010/02/07/creation-dynamic-loading-and-instrumentation-with-javaagents/
	    	 * http://www.eclemma.org/jacoco/trunk/doc/implementation.html
	    	 * http://osi.fotap.org/2008/06/27/dynamically-installing-agents-in-java-6/
	    	 * http://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html
	    	 */
	    	
	    	InstrumentingClassLoader classLoader = new InstrumentingClassLoader();
	        return Class.forName(clazz.getName(), true, classLoader);
	    } catch (ClassNotFoundException e) {
	        throw new InitializationError(e);
	    }
	}
}
